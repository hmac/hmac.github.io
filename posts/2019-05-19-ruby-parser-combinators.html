<!doctype html>
<html>
  <head>
  <title>Parser Combinators in Ruby | hmac.dev</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../css/syntax.css" />
  <style>
    html {
      height: 100%;
    }
    body { 
      height: 100%;
      background-color: #555;
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==);
      margin: 0px 0px 0px 0px;
    }
    .main {
      min-height: 100%;
      max-width: 700px;
      font-family: Georgia,Times New Roman,serif;
      font-size: 16px;
      line-height: 1.25;
      background-color: #fff;
    }
    .content {
      margin: 0px auto 0px auto;
      padding-bottom: 8px;
    }
    @media (min-width: 701px) {
      .main {
        margin: 0px auto 0px auto;
      }
      .content {
        max-width: 600px;
      }
    }
    @media (max-width: 700px) {
      .main {
        margin: 0px 0px 0px 0px;
      }
      .content {
        max-width: 600px;
        margin: 0px auto 0px auto;
      }
    }
    @media (max-width: 600px) {
      .main {
        margin: 0px 0px 0px 0px;
      }
      .content {
        max-width: 700px;
        margin: 0px 8px 0px 8px;
      }
      .sourceCode {
        font-size: 13px;
      }
    }
    h1, h2, h3 {
      font-family: Helvetica,Arial,sans-serif;
    }
    pre {
      font-size: 14px;
    }
    ol#post-list {
      list-style-type: none
    }
    #header {
      border-bottom: 1px solid black;
      padding: 10px 0px 10px 0px;
    }
    #header a {
      text-decoration: none;
    }
    #header #site {
      font-family: monospace;
      text-align: right;
      margin-right: 25px;
      color: black;
      float: right;
    }
    #header #site a {
      color: black;
    }
    #header #site a:hover {
      color: black;
    }
    #header #site a:visited {
      color: black;
    }
    #header #name {
      padding-left: 25px;
      background-color: #ffb3005e;
    }
    #header #name a {
      color: #292a31;
      font-family: Monaco,monospace;
    }
    #header #name a:visited {
      color: #292a31;
    }
    #header #name a:hover {
      color: #292a31;
    }

    a {
      text-decoration: none;
      color: #e6851f;
    }
    a:visited {
      text-decoration: none;
      color: #e6851f;
    }
    a:hover {
      text-decoration: none;
      color: #233248;
    }

    #date {
      font-size: 12px;
    }
  </style>
</head>

  <body>
    <div class="main">
      <div id="header">
        <h1 id="name"><a href="../">Harry Maclean</a></h1>
      </div>
      <div class="content">
        <div id="date">
          May 19, 2019
        </div>
        <h1 id="parser-combinators-in-ruby">Parser Combinators in Ruby</h1>
<p>Parser combinators are a technique common in FP languages for writing parsers - programs that convert textual input into a data structure native to the language. An ubiquitous example is a JSON parser, which almost every modern language has. Parser combinators are small building blocks that you compose together to form larger parsers. They’re nice for a number of reasons, but one is that the parser you end up with is extremely readable - often it looks very close to the formal grammar of the language you’re parsing. This makes it easy to spot bugs and extend in the future.</p>
<p>I won’t give a full introduction to parser combinators here. If you’re not familiar with them, there are a lot of tutorials floating about the internet. I particularly recommend <a href="http://eprints.nottingham.ac.uk/237/1/monparsing.pdf">Monadic Parser Combinators</a> by Graham Hutton and Erik Meijer. If you’ve written parsers in the past and found yourself in a bit of a mess of regular expressions and string munging, then you might consider parser combinators as an alternative. In this post I’m going to walk through the creation of a simple parser combinator library in Ruby and use it to build a parser for JSON. The library and JSON parser will each be about 100 LOC.</p>
<p>As an example of what we’re aiming for, here’s a parser written in the combinator style in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">parseNumberList <span class="fu">=</span> brackets (sepBy comma number)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">brackets p <span class="fu">=</span> between (string <span class="st">&quot;[&quot;</span>) (string <span class="st">&quot;]&quot;</span>) p</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">sepBy sep p <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  first <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  rest <span class="ot">&lt;-</span> many (sep <span class="fu">*&gt;</span> p)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  pure (first <span class="fu">:</span> rest)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">comma <span class="fu">=</span> string <span class="st">&quot;,&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">between open close inner <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  open</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  val <span class="ot">&lt;-</span> inner</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  close</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  pure val</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">number <span class="fu">=</span> <span class="fu">...</span></a></code></pre></div>
<p>The high level parser <code>parseNumberList</code> is constructed from small building blocks, including several parsers which modify other parsers: these are called <em>combinators</em>. <code>brackets</code> parses an open bracket, the given inner parser, and a closing bracket. <code>between</code> is a generic version of <code>brackets</code> which runs the three parsers provided in the same order. Because these parsers are generic we can reuse them in many places. For example, if we wanted a parser for a two-element tuple like <code>(1,2)</code> we might write:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">tuple <span class="fu">=</span> parens <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  fst <span class="ot">&lt;-</span> number</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  comma</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  snd <span class="ot">&lt;-</span> number</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  pure (fst, snd)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">parens p <span class="fu">=</span> between (string <span class="st">&quot;(&quot;</span>) (string <span class="st">&quot;)&quot;</span>) p</a></code></pre></div>
<p>The end result tends to be a very small amount of code and a very clear description of the language.</p>
<p>To parse in the combinator style you need two things: first class functions and custom flow control. In Ruby we’ll model these respectively using Procs and exceptions.</p>
<p>I’ll briefly describe Procs and exceptions - feel free to skip this part if you’re comfortable with them.</p>
<h2 id="procs">Procs</h2>
<p>Ruby’s equivalent of a first class function is the Proc (or lambda):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb3-1" data-line-number="1">add_one = proc { |x| x + <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">&gt; add_one.call(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">=&gt; <span class="dv">2</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">id = proc { |x| x }</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">&gt; id.call(<span class="st">&quot;ruby&quot;</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">=&gt; <span class="st">&quot;ruby&quot;</span></a></code></pre></div>
<p><code>proc</code> takes as argument a block, which is the body of the function. Any parameters in the block become formal parameters to the constructed Proc. Procs have access to any variables in scope when they are constructed, meaning that they form closures.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb4-1" data-line-number="1">a = <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">inc_a = proc { a += <span class="dv">1</span> }</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">inc_a.call</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">inc_a.call</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">&gt; a</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">=&gt; <span class="dv">3</span></a></code></pre></div>
<h2 id="exceptions">Exceptions</h2>
<p>When we write two sequential statements in a Ruby method, they will be executed in the usual imperative order.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">def</span> a</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  puts <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">end</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">def</span> b</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  puts <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">end</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">def</span> foo</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  a</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  b</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="kw">end</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">&gt; foo</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">a</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">b</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">=&gt; <span class="dv">nil</span></a></code></pre></div>
<p><code>a</code> has no way to control whether <code>b</code> is executed after it. However if <code>a</code> raises an exception then this changes: control will jump out of the method and any enclosing methods until we reach a matching <code>rescue</code> statement. We can abuse this feature to control how our parsers behave. Specifically, if a parser is made of several smaller parsers combined together, and one of the smaller parsers fail, we want the entire parser to fail. We want to be able to override this when necessary, but this should be the default.</p>
<h2 id="the-core">The Core</h2>
<p>Armed with these language features we can start to construct our parser. We’ll assume that the input is always a string, and we’ll track our progress through it with an index <code>loc</code> (lazy shorthand for “location”).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Parser</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="kw">def</span> initialize(input)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">@input</span> = input</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="ot">@loc</span> = <span class="dv">0</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="co"># ...</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">end</span></a></code></pre></div>
<p>The intuition is that our parsing methods will “consume” portions of the input, advancing the index as they do. Subsequent parses will only see the remaining input.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">def</span> input</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ot">@input</span>.byteslice(<span class="ot">@loc</span>..-<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">end</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">def</span> consume(num)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="ot">@loc</span> += num</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">end</span></a></code></pre></div>
<p>If a parse fails, we want to reset the index back to where it was before we started that parse. This behaviour is called backtracking, and it isn’t the only option in parser design, but we use it here because I think this behaviour makes it easier to write clear parsers.</p>
<p>To provide this behaviour we define a method <code>backtrack</code>, which takes a block. If that block fails to parse, <code>backtrack</code> will reset the index after it. How do we know if a parse has failed? We’ll use an exception. This has the nice property that if the parser consists of multiple parts and the first part fails, the subsequent parts will be skipped. Each parser doesn’t need to check if the previous parser succeeded, because if it had failed it would have raised an exception and we would never reach the second parser. This is what allows us to write parsers cleanly (as you’ll see in a minute) without any plumbing of checking return values between one and the next.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">def</span> backtrack</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  loc_before = <span class="ot">@loc</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">yield</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">rescue</span> <span class="dt">ParseFailure</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="ot">@loc</span> = loc_before</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="co"># re-raise the exception</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="co"># to propagate the failure</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  raise</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">end</span></a></code></pre></div>
<p>These three methods form the core of our parser: everything else can be constructed using them. First up, let’s define the most permissive parser: <code>take</code>. <code>take(n)</code> will parse <code>n</code> characters from the input. It will only fail if there are fewer than <code>n</code> characters left.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">def</span> take(len)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  match = input.byteslice(<span class="dv">0</span>, len)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">if</span> match.length &lt; len</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    raise <span class="dt">ParseFailure</span>, <span class="st">&quot;expected </span><span class="ot">#{</span>len<span class="ot">}</span><span class="st"> characters, but saw </span><span class="ot">#{</span>match.length<span class="ot">}</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  consume(len)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  match</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">end</span></a></code></pre></div>
<p>We first fetch <code>len</code> characters, raising <code>ParseFailure</code> if we don’t get enough characters. We then <code>consume</code> the characters we’ve just fetched, and return them. This is how it behaves:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb10-1" data-line-number="1">p = <span class="dt">Parser</span>.new(<span class="st">&quot;what a great example&quot;</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">p.take(<span class="dv">100</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">=&gt; <span class="dt">Parser</span>::<span class="dt">ParseFailure</span>:</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">   expected <span class="dv">100</span> characters, but saw <span class="dv">20</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">p.take(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">=&gt; <span class="st">&quot;what&quot;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">p.take(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">=&gt; <span class="st">&quot; a&quot;</span></a></code></pre></div>
<p>Next up: string literals.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">def</span> string(pat)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  backtrack <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    s = take(pat.length)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    fail(pat, s) <span class="kw">unless</span> s == pat</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    s</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">end</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="kw">def</span> fail(expected, actual)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  raise <span class="dt">ParseFailure</span>, <span class="st">&quot;expected </span><span class="ot">#{</span>expected.inspect<span class="ot">}</span><span class="st"> but saw </span><span class="ot">#{</span>actual.inspect<span class="ot">}</span><span class="st"> (</span><span class="ot">#{@loc}</span><span class="st">)&quot;</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="kw">end</span></a></code></pre></div>
<p><code>string(&quot;abc&quot;)</code> will succeed if the input starts with the string <code>abc</code>. To implement it, we <code>take</code> enough characters to match the length of the given string, and then check if they match. If they don’t, we raise <code>ParseFailure</code> (via a convenience method <code>fail</code>). We wrap all of this in <code>backtrack</code> to ensure that when we do fail, we roll back the index.</p>
<p>Finally, we’ll want a way to repeatedly parse characters matching some predicate. This is <code>take_while</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">def</span> take_while(pred)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"> input.chars.take_while(&amp;pred).join.tap { |match| consume(match.length) }</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">end</span></a></code></pre></div>
<p>We can now write simple parsers, such as this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> <span class="dt">PurchaseOrder</span> &lt; <span class="dt">Parser</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">def</span> run</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    string <span class="st">&quot;BUY: &quot;</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    take_while proc { |c| c != <span class="st">&quot;\n&quot;</span> }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="kw">end</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">&gt; <span class="dt">Order</span>.new(<span class="st">&quot;BUY: eggs&quot;</span>).run</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">=&gt; <span class="st">&quot;eggs&quot;</span></a></code></pre></div>
<h2 id="combinators">Combinators</h2>
<p>To complete our parser, we need ways to compose these primitives together. This is where we’ll meet our combinators. The first is <code>either</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">def</span> either(parser1, parser2)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  backtrack { parser1.call }</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="kw">rescue</span> <span class="dt">ParseFailure</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  parser2.call</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="kw">end</span></a></code></pre></div>
<p><code>either</code> takes two parsers as arguments. It tries the first, and if that fails it backtracks and tries the second.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb15-1" data-line-number="1">run = proc <span class="kw">do</span> |input|</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  p = <span class="dt">Parser</span>.new(input)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  p.either(</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    proc { p.string(<span class="st">&quot;foo&quot;</span>) },</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    proc { p.string(<span class="st">&quot;bar&quot;</span>) },</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  )</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">end</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">run.(<span class="st">&quot;foo&quot;</span>)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">=&gt; <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">run.(<span class="st">&quot;bar&quot;</span>)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">=&gt; <span class="st">&quot;bar&quot;</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">run.(<span class="st">&quot;cat&quot;</span>)</a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="dt">Parser</span>::<span class="dt">ParseFailure</span>:</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">  expected <span class="st">&quot;bar&quot;</span> but saw <span class="st">&quot;cat&quot;</span> (<span class="dv">3</span>)</a></code></pre></div>
<p>Next we have <code>zero_or_more</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">def</span> zero_or_more(parser)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  matches = []</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  loop { matches &lt;&lt; backtrack { parser.call } }</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="kw">rescue</span> <span class="dt">ParseFailure</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  matches</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">end</span></a></code></pre></div>
<p><code>zero_or_more</code> takes a parser and tries to apply it as many times as possible, returning an array of results. It always succeeds, as the parser can match zero times. This is analogous to the <code>*</code> regex operator.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb17-1" data-line-number="1">run = proc <span class="kw">do</span> |input|</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  p = <span class="dt">Parser</span>.new(input)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  p.zero_or_more(proc { p.string(<span class="st">&quot;a&quot;</span>) })</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">end</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">run.(<span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">=&gt; [<span class="st">&quot;a&quot;</span>]</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">run.(<span class="st">&quot;aaaabb&quot;</span>)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">=&gt; [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>]</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">run.(<span class="st">&quot;baaa&quot;</span>)</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">=&gt; []</a></code></pre></div>
<p>If we want the behaviour of regex <code>+</code>, we can use <code>at_least_one</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">def</span> at_least_one(parser)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  first = parser.call</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  rest = zero_or_more(parser)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  [first, *rest]</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="kw">end</span></a></code></pre></div>
<p><code>at_least_one</code> is identical to <code>zero_or_more</code> except that the parser must succeed at least once.</p>
<p>The last combinator we’ll look at is <code>sep_by</code>, which is the same as <code>sepBy</code> in the Haskell example from the start. Given a separator and a parser, it will try to parse repeated instances of the parser interspersed with the separator (which is itself a parser).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">def</span> sep_by(separator, parser)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  first = <span class="kw">begin</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">            backtrack { parser.call }</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">          <span class="kw">rescue</span> <span class="dt">ParseFailure</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">            <span class="kw">return</span> []</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">          <span class="kw">end</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  combined = proc <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    separator.call</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    parser.call</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  rest = zero_or_more combined</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">  [first, *rest]</a>
<a class="sourceLine" id="cb19-14" data-line-number="14"><span class="kw">end</span></a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb20-1" data-line-number="1">run = proc <span class="kw">do</span> |input|</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  p = <span class="dt">Parser</span>.new(input)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  p.sep_by(</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    proc { p.string(<span class="st">&quot;,&quot;</span>) },</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    proc { p.take(<span class="dv">1</span>) },</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  )</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="kw">end</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">run.(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">=&gt; []</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">run.(<span class="st">&quot;1,2,3&quot;</span>)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">=&gt; [<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>]</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">run.(<span class="st">&quot;1,2,3,45&quot;</span>)</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">=&gt; [<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>, <span class="st">&quot;4&quot;</span>]</a></code></pre></div>
<p>That’s basically it! There are a couple more combinators we could define, like <code>optional</code>, <code>one_of</code> and <code>between</code>, but they are straightforward. Let’s look instead at writing a real world parser with this tooling.</p>
<h2 id="parsing-json">Parsing JSON</h2>
<p>We’re going to write a mostly-compliant JSON parser. It won’t handle unicode and its floating point behaviour will be a bit broken, but it will otherwise work correctly. I’ve tested it against the fixtures in the <a href="https://github.com/nst/JSONTestSuite/">JSON Parsing Test Suite</a> and it passes 109 of the 141 <code>y_</code> tests (samples that must be accepted by the parser). In total, the whole parser is 119 lines long.</p>
<p>To start, we define our class and entrypoint</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> <span class="dt">JsonParser</span> &lt; <span class="dt">Parser</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  <span class="kw">def</span> run</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    json_value</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="kw">end</span></a></code></pre></div>
<p><code>json_value</code> parses, well, any JSON value.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">def</span> json_value</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  one_of [</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    method(<span class="st">:object</span>),</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    method(<span class="st">:array</span>),</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    method(<span class="st">:quoted_string</span>),</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    method(<span class="st">:boolean</span>),</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    method(<span class="st">:null</span>),</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">    method(<span class="st">:number</span>),</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">  ]</a>
<a class="sourceLine" id="cb22-10" data-line-number="10"><span class="kw">end</span></a></code></pre></div>
<p><code>one_of</code> is a combinator that acts like a variadic <code>either</code>: it will try each parser in turn until one succeeds. Each of the parsers given to it is a method on our class, so we convert them to first class objects using <a href="https://ruby-doc.org/core-2.6/Object.html#method-i-method"><code>Object#method</code></a>. This will allow us to <code>#call</code> them just like Procs. We’ll walk through each of these methods in turn.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">def</span> object</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  inner = proc <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    kvs = sep_by method(<span class="st">:comma</span>), method(<span class="st">:key_value_pair</span>)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="dt">Hash</span>[kvs]</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  between proc { token <span class="st">&quot;{&quot;</span> },</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">          proc { token <span class="st">&quot;}&quot;</span> },</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">          inner</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="kw">end</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10"></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="kw">def</span> token(str)</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  string(str).tap { skip_spaces }</a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="kw">end</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14"></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"><span class="kw">def</span> skip_spaces</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">  take_while(proc { |c| [<span class="st">&quot; &quot;</span>, <span class="st">&quot;\n&quot;</span>].include?(c) })</a>
<a class="sourceLine" id="cb23-17" data-line-number="17"><span class="kw">end</span></a></code></pre></div>
<p><code>object</code> uses <code>between</code> to parse the opening and closing brackets. Inside the brackets we parse a series of key-value pairs. We use <code>sep_by</code> with a separator of <code>comma</code> (which does what you’d expect), and an inner parser of <code>key_value_pair</code>. This gives us a nested array which we convert to a Hash before returning. To parse the brackets we use <code>token</code>, which is a wrapper around <code>string</code> which consumes any trailing whitespace. We’ll use it throughout the parser - it allows us to largely ignore whitespace and keep things concise.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">def</span> key_value_pair</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  key = quoted_string</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  token <span class="st">&quot;:&quot;</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  value = json_value</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  [key, value]</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="kw">end</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7"></a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="kw">def</span> quoted_string</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  str = between proc { string <span class="st">&quot;\&quot;&quot;</span> },</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">                proc { token <span class="st">&quot;\&quot;&quot;</span> },</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">                proc { take_while(proc { |c| c != <span class="st">&quot;\&quot;&quot;</span> }) }</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">  str</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="kw">end</span></a></code></pre></div>
<p><code>key_value_pair</code> is a string enclosed in quotes followed by a semicolon, followed by any JSON value. We naïvely assume that a string is any sequence of characters excluding the double quote character. This obviously doesn’t cater for escape characters, but we’ll conveniently ignore that. Note that we can’t use <code>token</code> for the opening quote in <code>quoted_string</code> because any trailing whitespace after that character forms part of the string we’re trying to parse.</p>
<p>That’s JSON objects, then. Next up, arrays:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">def</span> array</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  res = between proc { token <span class="st">&quot;[&quot;</span> },</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">                proc { token <span class="st">&quot;]&quot;</span> },</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">                proc { sep_by method(<span class="st">:comma</span>), method(<span class="st">:json_value</span>) }</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  res</a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">end</span></a></code></pre></div>
<p>We again use <code>between</code> to handle the enclosing brackets, and inside them we just parse a series of JSON values separated by commas.</p>
<p>Booleans and <code>null</code>s are very simple:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">def</span> boolean</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  bool = either proc { token <span class="st">&quot;true&quot;</span> }, proc { token <span class="st">&quot;false&quot;</span> }</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  bool == <span class="st">&quot;true&quot;</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="kw">end</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="kw">def</span> null</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  token <span class="st">&quot;null&quot;</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  <span class="dv">nil</span></a>
<a class="sourceLine" id="cb26-9" data-line-number="9"><span class="kw">end</span></a></code></pre></div>
<p>And all that’s left is numbers. JSON has one number type, which is the float. Parsing floats is a bit complex as we have to deal with positive/negative signs, decimals and exponents, but we can cater for all of that without a huge amount of code. It is, however, a little less clear than what we’ve covered so far. I’ll leave it as an exercise to work out what we’re doing here - hopefully it’s not too hard!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">def</span> number</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  sign = optional method(<span class="st">:sign</span>)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  result = integer</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  decimals = optional(proc { string <span class="st">&quot;.&quot;</span>; integer })</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">  exponent = optional(proc <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    either(proc { string <span class="st">&quot;e&quot;</span> }, proc { string <span class="st">&quot;E&quot;</span> })</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    signed_integer</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  <span class="kw">end</span>)</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10">  result = result.to_f <span class="kw">if</span> decimals || exponent</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">  result += (decimals.to_f / (<span class="dv">10</span>**decimals.to_s.length)) <span class="kw">if</span> decimals</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">  result *= <span class="dv">10</span>**exponent.to_f <span class="kw">if</span> exponent</a>
<a class="sourceLine" id="cb27-13" data-line-number="13">  sign == <span class="st">&quot;-&quot;</span> ? <span class="dv">0</span> - result : result</a>
<a class="sourceLine" id="cb27-14" data-line-number="14"><span class="kw">end</span></a>
<a class="sourceLine" id="cb27-15" data-line-number="15"></a>
<a class="sourceLine" id="cb27-16" data-line-number="16"><span class="kw">def</span> signed_integer</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">  sign = optional method(<span class="st">:sign</span>)</a>
<a class="sourceLine" id="cb27-18" data-line-number="18">  n = integer</a>
<a class="sourceLine" id="cb27-19" data-line-number="19">  sign == <span class="st">&quot;-&quot;</span> ? <span class="dv">0</span> - n : n</a>
<a class="sourceLine" id="cb27-20" data-line-number="20"><span class="kw">end</span></a>
<a class="sourceLine" id="cb27-21" data-line-number="21"></a>
<a class="sourceLine" id="cb27-22" data-line-number="22"><span class="dt">INTEGERS</span> = (<span class="dv">0</span>..<span class="dv">9</span>).map(&amp;<span class="st">:to_s</span>)</a>
<a class="sourceLine" id="cb27-23" data-line-number="23"><span class="kw">def</span> integer</a>
<a class="sourceLine" id="cb27-24" data-line-number="24">  int = proc <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-25" data-line-number="25">    char = take <span class="dv">1</span></a>
<a class="sourceLine" id="cb27-26" data-line-number="26">    fail(<span class="st">&quot;one of </span><span class="ot">#{</span><span class="dt">INTEGERS</span><span class="ot">}</span><span class="st">&quot;</span>, char) <span class="kw">unless</span> <span class="dt">INTEGERS</span>.include?(char)</a>
<a class="sourceLine" id="cb27-27" data-line-number="27"></a>
<a class="sourceLine" id="cb27-28" data-line-number="28">    char</a>
<a class="sourceLine" id="cb27-29" data-line-number="29">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb27-30" data-line-number="30"></a>
<a class="sourceLine" id="cb27-31" data-line-number="31">  numstr = at_least_one int</a>
<a class="sourceLine" id="cb27-32" data-line-number="32">  skip_spaces</a>
<a class="sourceLine" id="cb27-33" data-line-number="33">  numstr.join.to_i</a>
<a class="sourceLine" id="cb27-34" data-line-number="34"><span class="kw">end</span></a>
<a class="sourceLine" id="cb27-35" data-line-number="35"></a>
<a class="sourceLine" id="cb27-36" data-line-number="36"><span class="kw">def</span> sign</a>
<a class="sourceLine" id="cb27-37" data-line-number="37">  either proc { token <span class="st">&quot;-&quot;</span> },</a>
<a class="sourceLine" id="cb27-38" data-line-number="38">         proc { token <span class="st">&quot;+&quot;</span> }</a>
<a class="sourceLine" id="cb27-39" data-line-number="39"><span class="kw">end</span></a></code></pre></div>
<p>That’s the whole thing. Let’s try it out on some JSON.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="dt">JsonParser</span>.new(<span class="st">&quot;{}&quot;</span>).run</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">=&gt; {}</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="dt">JsonParser</span>.new(<span class="st">&quot;[]&quot;</span>).run</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">=&gt; []</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"></a>
<a class="sourceLine" id="cb28-7" data-line-number="7"><span class="dt">JsonParser</span>.new(<span class="st">&quot;4&quot;</span>).run</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">=&gt; <span class="dv">4</span></a>
<a class="sourceLine" id="cb28-9" data-line-number="9"></a>
<a class="sourceLine" id="cb28-10" data-line-number="10"><span class="dt">JsonParser</span>.new(&lt;&lt;<span class="kw">EOF</span><span class="ot">).run</span></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="ot">{</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12"><span class="ot">  &quot;a&quot;:   &quot;sample&quot;,</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13"><span class="ot">  &quot;json&quot;  : &quot;object&quot;</span></a>
<a class="sourceLine" id="cb28-14" data-line-number="14"><span class="ot">}</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15"><span class="kw">EOF</span></a>
<a class="sourceLine" id="cb28-16" data-line-number="16">=&gt; {<span class="st">&quot;a&quot;</span>=&gt;<span class="st">&quot;sample&quot;</span>, <span class="st">&quot;json&quot;</span>=&gt;<span class="st">&quot;object&quot;</span>}</a>
<a class="sourceLine" id="cb28-17" data-line-number="17"></a>
<a class="sourceLine" id="cb28-18" data-line-number="18"><span class="dt">JsonParser</span>.new(&lt;&lt;<span class="kw">EOF</span><span class="ot">).run</span></a>
<a class="sourceLine" id="cb28-19" data-line-number="19"><span class="ot">{</span></a>
<a class="sourceLine" id="cb28-20" data-line-number="20"><span class="ot">  &quot;a&quot;: &quot;sample&quot;,</span></a>
<a class="sourceLine" id="cb28-21" data-line-number="21"><span class="ot">  &quot;json&quot;: &quot;object&quot;,</span></a>
<a class="sourceLine" id="cb28-22" data-line-number="22"><span class="ot">  &quot;with&quot;: [</span></a>
<a class="sourceLine" id="cb28-23" data-line-number="23"><span class="ot">    &quot;an&quot;,</span></a>
<a class="sourceLine" id="cb28-24" data-line-number="24"><span class="ot">    &quot;array&quot;,</span></a>
<a class="sourceLine" id="cb28-25" data-line-number="25"><span class="ot">    -1.23e3,</span></a>
<a class="sourceLine" id="cb28-26" data-line-number="26"><span class="ot">    { &quot;two&quot;: &quot;three&quot; }</span></a>
<a class="sourceLine" id="cb28-27" data-line-number="27"><span class="ot">  ]</span></a>
<a class="sourceLine" id="cb28-28" data-line-number="28"><span class="ot">}</span></a>
<a class="sourceLine" id="cb28-29" data-line-number="29"><span class="kw">EOF</span></a>
<a class="sourceLine" id="cb28-30" data-line-number="30">=&gt; {</a>
<a class="sourceLine" id="cb28-31" data-line-number="31">     <span class="st">&quot;a&quot;</span> =&gt; <span class="st">&quot;sample&quot;</span>,</a>
<a class="sourceLine" id="cb28-32" data-line-number="32">     <span class="st">&quot;json&quot;</span> =&gt; <span class="st">&quot;object&quot;</span>,</a>
<a class="sourceLine" id="cb28-33" data-line-number="33">     <span class="st">&quot;with&quot;</span> =&gt; [</a>
<a class="sourceLine" id="cb28-34" data-line-number="34">       <span class="st">&quot;an&quot;</span>,</a>
<a class="sourceLine" id="cb28-35" data-line-number="35">       <span class="st">&quot;array&quot;</span>,</a>
<a class="sourceLine" id="cb28-36" data-line-number="36">       <span class="dv">-1230</span>.<span class="dv">0</span>,</a>
<a class="sourceLine" id="cb28-37" data-line-number="37">       { <span class="st">&quot;two&quot;</span> =&gt; <span class="st">&quot;three&quot;</span> }</a>
<a class="sourceLine" id="cb28-38" data-line-number="38">      ]</a>
<a class="sourceLine" id="cb28-39" data-line-number="39">   }</a>
<a class="sourceLine" id="cb28-40" data-line-number="40"></a>
<a class="sourceLine" id="cb28-41" data-line-number="41"><span class="dt">JsonParser</span>.new(<span class="st">&quot;bad input&quot;</span>).run</a>
<a class="sourceLine" id="cb28-42" data-line-number="42">=&gt; <span class="dt">Parser</span>::<span class="dt">ParseFailure</span>: expected one <span class="st">of: </span>[</a>
<a class="sourceLine" id="cb28-43" data-line-number="43">  <span class="co">#&lt;Method: JsonParser#object&gt;,</span></a>
<a class="sourceLine" id="cb28-44" data-line-number="44">  <span class="co">#&lt;Method: JsonParser#array&gt;,</span></a>
<a class="sourceLine" id="cb28-45" data-line-number="45">  <span class="co">#&lt;Method: JsonParser#quoted_string&gt;,</span></a>
<a class="sourceLine" id="cb28-46" data-line-number="46">  <span class="co">#&lt;Method: JsonParser#boolean&gt;,</span></a>
<a class="sourceLine" id="cb28-47" data-line-number="47">  <span class="co">#&lt;Method: JsonParser#null&gt;,</span></a>
<a class="sourceLine" id="cb28-48" data-line-number="48">  <span class="co">#&lt;Method: JsonParser#number&gt;</span></a>
<a class="sourceLine" id="cb28-49" data-line-number="49">]</a>
<a class="sourceLine" id="cb28-50" data-line-number="50">from lib/parser.rb:<span class="dv">60</span><span class="st">:in</span> <span class="st">`one_of'</span></a></code></pre></div>
<p>And that’s it! A (mostly) complete JSON parser in around 100 LOC. Hopefully that gives you an idea of how you can take these parsing techniques and apply them outside of functional programming languages.</p>
<h2 id="performance">Performance</h2>
<p>There’s one final thing to address, and that is performance. Ruby isn’t known for its speed, and for tasks like this it often delegates to an underlying C library to do the heavy lifting - this is the case for most JSON, YAML and XML parsers. The parser we’ve written here is, comparatively, extremely slow: parsing a 100KB JSON document on my laptop takes 3.5 seconds compared to ~0.15 seconds using the Ruby standard library JSON parser<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. I’m not yet sure whether this is due to slow string indexing, repeated backtracking, overuse of exceptions, or something else - it would be quite interesting to find out. Until then, just keep in mind that whilst these techniques do translate, the tradeoffs might be very different between languages!</p>
<p>You can find all the code for this post <a href="https://github.com/hmac/rubyparsers">here</a>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A more idiomatic definition of <code>take_while</code> would take a block argument rather than a proc, so that you can write <code>take_while { |c| ... }</code>. I’ve not done this here to keep the usage of Procs consistent, but you could certainly do so in the real world.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>To be specific, the <a href="https://github.com/ruby/ruby/blob/trunk/ext/json/parser/parser.c"><code>ext</code></a> implementation, which is 2000 lines of C, rather than the pure Ruby implementation.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
      </div>
    </div>
  </body>
</html>
