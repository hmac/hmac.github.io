<!doctype html>
<html>
  <head>
  <title>Implementing A Functional Language | hmac.dev</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../css/syntax.css" />
  <style>
    html {
      height: 100%;
    }
    body { 
      height: 100%;
      background-color: #fff;
      margin: 0px 0px 0px 0px;
    }
    .main {
      min-height: 100%;
      max-width: 900px;
      font-family: Helvetica Neue;
      font-size: 16px;
      line-height: 1.7em;
    }
    .content {
      margin: 0px auto 0px auto;
      padding-bottom: 8px;
      padding-left: 10px;
      padding-right: 10px;
      color: #333;
      font-size: 1.1em;
    }
    .content code:not(.sourceCode) {
      background-color: #f7f5ef;
      color: #444;
    }
    div.sourceCode {
      padding: 5px;
    }
    @media (min-width: 701px) {
      .main {
        margin: 0px auto 0px auto;
      }
    }
    @media (max-width: 700px) {
      .main {
        margin: 0px 0px 0px 0px;
      }
      .content {
        max-width: 600px;
        margin: 0px auto 0px auto;
      }
    }
    @media (max-width: 600px) {
      .main {
        margin: 0px 0px 0px 0px;
      }
      .content {
        max-width: 700px;
        margin: 0px 8px 0px 8px;
      }
      .sourceCode {
        font-size: 13px;
      }
    }
    h1, h2, h3 {
      font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
      font-weight: normal;
    }
    ol#post-list {
      list-style-type: none
    }
    #header {
      border-bottom: 1px solid black;
      padding: 10px 0px 10px 0px;
      position: relative;
      min-height: 30px;
    }
    #header a {
      text-decoration: none;
    }
    #header #back {
      position: absolute;
      left: 0;
    }
    #header #date {
      position: absolute;
      right: 1em;
    }
    #header #name {
      position: absolute;
      right: 1em;
    }

    a {
      text-decoration: none;
      color: #e6851f;
    }
    a:visited {
      text-decoration: none;
      color: #e6851f;
    }
    a:hover {
      text-decoration: none;
      color: #233248;
    }
    .project p {
      margin-left: 1em;
    }
  </style>
</head>

  <body>
    <div class="main">
      <div id="header">
        <a id="back" href="../">↩</a>
        <div id="date">March  2, 2019</div>
      </div>
      <div class="content">
        <h1 id="implementing-a-functional-language">Implementing A Functional Language</h1>
<p>This is the first in a series of posts on implementing a simple functional language. A
typical functional language compiler goes through the following steps to turn the code you
write into a binary you run:</p>
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 5.0.0 (0)
 -->
<!-- Pages: 1 -->
<svg width="172pt" height="479pt" viewBox="0.00 0.00 172.24 479.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 475)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-475 168.24,-475 168.24,4 -4,4"></polygon>
<!-- your code -->
<g id="node1" class="node">
<title>your code</title>
<ellipse fill="none" stroke="black" cx="81.24" cy="-453" rx="50.09" ry="18"></ellipse>
<text text-anchor="middle" x="81.24" y="-449.3" font-family="Courier,monospace" font-size="14.00">your code</text>
</g>
<!-- ast -->
<g id="node2" class="node">
<title>ast</title>
<ellipse fill="none" stroke="black" cx="81.24" cy="-366" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="81.24" y="-362.3" font-family="Courier,monospace" font-size="14.00">ast</text>
</g>
<!-- your code&#45;&gt;ast -->
<g id="edge1" class="edge">
<title>your code-&gt;ast</title>
<path fill="none" stroke="black" d="M81.24,-434.8C81.24,-423.16 81.24,-407.55 81.24,-394.24"></path>
<polygon fill="black" stroke="black" points="84.74,-394.18 81.24,-384.18 77.74,-394.18 84.74,-394.18"></polygon>
<text text-anchor="middle" x="104.24" y="-405.8" font-family="Times,serif" font-size="14.00"> PARSE</text>
</g>
<!-- annotated ast -->
<g id="node3" class="node">
<title>annotated ast</title>
<ellipse fill="none" stroke="black" cx="81.24" cy="-279" rx="67.69" ry="18"></ellipse>
<text text-anchor="middle" x="81.24" y="-275.3" font-family="Courier,monospace" font-size="14.00">annotated ast</text>
</g>
<!-- ast&#45;&gt;annotated ast -->
<g id="edge2" class="edge">
<title>ast-&gt;annotated ast</title>
<path fill="none" stroke="black" d="M81.24,-347.8C81.24,-336.16 81.24,-320.55 81.24,-307.24"></path>
<polygon fill="black" stroke="black" points="84.74,-307.18 81.24,-297.18 77.74,-307.18 84.74,-307.18"></polygon>
<text text-anchor="middle" x="122.74" y="-318.8" font-family="Times,serif" font-size="14.00"> TYPECHECK</text>
</g>
<!-- core -->
<g id="node4" class="node">
<title>core</title>
<ellipse fill="none" stroke="black" cx="81.24" cy="-192" rx="28.7" ry="18"></ellipse>
<text text-anchor="middle" x="81.24" y="-188.3" font-family="Courier,monospace" font-size="14.00">core</text>
</g>
<!-- annotated ast&#45;&gt;core -->
<g id="edge3" class="edge">
<title>annotated ast-&gt;core</title>
<path fill="none" stroke="black" d="M81.24,-260.8C81.24,-249.16 81.24,-233.55 81.24,-220.24"></path>
<polygon fill="black" stroke="black" points="84.74,-220.18 81.24,-210.18 77.74,-220.18 84.74,-220.18"></polygon>
<text text-anchor="middle" x="115.24" y="-231.8" font-family="Times,serif" font-size="14.00"> DESUGAR</text>
</g>
<!-- abstract IR -->
<g id="node5" class="node">
<title>abstract IR</title>
<ellipse fill="none" stroke="black" cx="81.24" cy="-105" rx="59.29" ry="18"></ellipse>
<text text-anchor="middle" x="81.24" y="-101.3" font-family="Courier,monospace" font-size="14.00">abstract IR</text>
</g>
<!-- core&#45;&gt;abstract IR -->
<g id="edge4" class="edge">
<title>core-&gt;abstract IR</title>
<path fill="none" stroke="blue" d="M81.24,-173.8C81.24,-162.16 81.24,-146.55 81.24,-133.24"></path>
<polygon fill="blue" stroke="blue" points="84.74,-133.18 81.24,-123.18 77.74,-133.18 84.74,-133.18"></polygon>
<text text-anchor="middle" x="113.24" y="-144.8" font-family="Times,serif" font-size="14.00"> COMPILE</text>
</g>
<!-- backend language -->
<g id="node6" class="node">
<title>backend language</title>
<ellipse fill="none" stroke="black" cx="81.24" cy="-18" rx="81.49" ry="18"></ellipse>
<text text-anchor="middle" x="81.24" y="-14.3" font-family="Courier,monospace" font-size="14.00">backend language</text>
</g>
<!-- abstract IR&#45;&gt;backend language -->
<g id="edge5" class="edge">
<title>abstract IR-&gt;backend language</title>
<path fill="none" stroke="black" d="M81.24,-86.8C81.24,-75.16 81.24,-59.55 81.24,-46.24"></path>
<polygon fill="black" stroke="black" points="84.74,-46.18 81.24,-36.18 77.74,-46.18 84.74,-46.18"></polygon>
<text text-anchor="middle" x="115.74" y="-57.8" font-family="Times,serif" font-size="14.00"> CODEGEN</text>
</g>
</g>
</svg>

<p>We will look at the transformation from <code>core</code> to <code>abstract IR</code>. In Haskell, this
corresponds to the transformation from GHC Core to STG. This process is interesting
because it is here that we define <em>how the program is evaluated</em>. We will look at several
different designs for compilers, of increasing complexity, and consider problems such as
laziness, sharing, garbage collection, strictness analysis and parallel evaluation.</p>
<p>This series is heavily based on a fantastic book of the same name written by Simon Peyton
Jones and David Lester in 2000. All credit goes to them for the content: I’ve simply
altered the presentation and updated it slightly. There are a number of differences:</p>
<ul>
<li>The book uses Miranda as its implementation language, whereas we will use Haskell.</li>
<li>Some time is spent in the book on introducing parser combinators and pretty printing,
whereas we will not focus on these them. Parsing and pretty printing are topics in their
own right, and there are better introductions to them elsewhere.</li>
<li>No external libraries are used in the book, whereas we will use a few common ones in the
interest of brevity.</li>
<li>We will spend time on building a framework for visualising the evaluation process, as I
think that makes it easier to understand how the compiler works.</li>
</ul>
<p>The book is freely available in PDF form <a href="https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/">here</a>. There’s also a broader overview of
this area (again by Simon Peyton Jones) available <a href="https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/">here</a>. I highly recommend both of
them.</p>
<h2 id="structure">Structure</h2>
<p>The structure of this series is as follows. However this is a work in progress, so I may
change things as I complete each section.</p>
<ol type="1">
<li><a href="2019-03-03-the-core-language.html">The Core Language</a></li>
<li><a href="2019-03-09-graph-reduction.html">Graph Reduction</a></li>
<li>Template Instantiation</li>
<li>The G-machine</li>
<li>The Three Instruction Machine</li>
<li>The Parallel G-machine</li>
<li>Lambda Lifting</li>
<li>The Spineless Tagless G-machine</li>
<li><a href="2019-03-03-printing-core.html">Appendix: Printing Core</a></li>
<li><a href="2019-03-08-parsing-core.html">Appendix: Parsing Core</a></li>
</ol>
<p>Each post will be a literate Haskell file, and will compile using Stackage <code>lts-12.2</code>.
We’ll use several libraries from Hackage, so you’ll want to make sure you’re using the
same versions. Compiling with Stack and <code>lts-12.2</code> is the easiest way to do this.</p>
      </div>
    </div>
  </body>
</html>
