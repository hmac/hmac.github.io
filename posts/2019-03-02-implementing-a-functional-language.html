<!doctype html>
<html>
  <head>
  <title>Implementing A Functional Language | hmac.dev</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../css/syntax.css" />
  <style>
    body {
      max-width: 700px;
      font-family: Palatino,Times New Roman,serif;
      margin: 0px auto 0px auto;
      font-size: 16px;
      line-height: 1.25;
      background-color: #f2f2f2;
    }
    pre {
      font-size: 14px;
    }
    ol#post-list {
      list-style-type: none
    }
    #header {
      border-bottom: 1px solid black;
      padding: 10px 0px 10px 0px;
    }
    #header #site {
      font-family: monospace;
      text-align: right
    }
    #header #name {
      float: left
    }
    #header a {
      text-decoration: none;
      color: black;
    }
    #header a:visited {
      color: black;
    }
    #header a:hover {
      color: black;
    }
    a {
      color: #233248;
    }
    #date {
      font-size: 12px;
    }
  </style>
</head>

  <body>
    <div id="header">
      <h2 id="site"><a href="../">hmac.dev</a></h2>
    </div>
    <div id="date">
      March  2, 2019
    </div>
    <h1 id="implementing-a-functional-language">Implementing A Functional Language</h1>
<p>This is the first in a series of posts on implementing a simple functional language. A typical functional language compiler goes through the following steps to turn the code you write into a binary you run:</p>
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="198pt" height="474pt" viewBox="0.00 0.00 198.04 474.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 470)">
<title>%3</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-470 194.0358,-470 194.0358,4 -4,4"></polygon>
<!-- your code -->
<g id="node1" class="node">
<title>your code</title>
<ellipse fill="none" stroke="#000000" cx="95.0179" cy="-448" rx="57.7389" ry="18"></ellipse>
<text text-anchor="middle" x="95.0179" y="-443.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">your code</text>
</g>
<!-- ast -->
<g id="node2" class="node">
<title>ast</title>
<ellipse fill="none" stroke="#000000" cx="95.0179" cy="-362" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="95.0179" y="-357.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">ast</text>
</g>
<!-- your code&#45;&gt;ast -->
<g id="edge1" class="edge">
<title>your code-&gt;ast</title>
<path fill="none" stroke="#000000" d="M95.0179,-429.7616C95.0179,-418.3597 95.0179,-403.4342 95.0179,-390.494"></path>
<polygon fill="#000000" stroke="#000000" points="98.518,-390.2121 95.0179,-380.2121 91.518,-390.2121 98.518,-390.2121"></polygon>
<text text-anchor="middle" x="117.9115" y="-400.8" font-family="Times,serif" font-size="14.00" fill="#000000"> PARSE</text>
</g>
<!-- annotated ast -->
<g id="node3" class="node">
<title>annotated ast</title>
<ellipse fill="none" stroke="#000000" cx="95.0179" cy="-276" rx="79.1943" ry="18"></ellipse>
<text text-anchor="middle" x="95.0179" y="-271.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">annotated ast</text>
</g>
<!-- ast&#45;&gt;annotated ast -->
<g id="edge2" class="edge">
<title>ast-&gt;annotated ast</title>
<path fill="none" stroke="#000000" d="M95.0179,-343.7616C95.0179,-332.3597 95.0179,-317.4342 95.0179,-304.494"></path>
<polygon fill="#000000" stroke="#000000" points="98.518,-304.2121 95.0179,-294.2121 91.518,-304.2121 98.518,-304.2121"></polygon>
<text text-anchor="middle" x="137.869" y="-314.8" font-family="Times,serif" font-size="14.00" fill="#000000"> TYPECHECK</text>
</g>
<!-- core -->
<g id="node4" class="node">
<title>core</title>
<ellipse fill="none" stroke="#000000" cx="95.0179" cy="-190" rx="31.1701" ry="18"></ellipse>
<text text-anchor="middle" x="95.0179" y="-185.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">core</text>
</g>
<!-- annotated ast&#45;&gt;core -->
<g id="edge3" class="edge">
<title>annotated ast-&gt;core</title>
<path fill="none" stroke="#000000" d="M95.0179,-257.7616C95.0179,-246.3597 95.0179,-231.4342 95.0179,-218.494"></path>
<polygon fill="#000000" stroke="#000000" points="98.518,-218.2121 95.0179,-208.2121 91.518,-218.2121 98.518,-218.2121"></polygon>
<text text-anchor="middle" x="129.8265" y="-228.8" font-family="Times,serif" font-size="14.00" fill="#000000"> DESUGAR</text>
</g>
<!-- abstract IR -->
<g id="node5" class="node">
<title>abstract IR</title>
<ellipse fill="none" stroke="#000000" cx="95.0179" cy="-104" rx="68.4664" ry="18"></ellipse>
<text text-anchor="middle" x="95.0179" y="-99.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">abstract IR</text>
</g>
<!-- core&#45;&gt;abstract IR -->
<g id="edge4" class="edge">
<title>core-&gt;abstract IR</title>
<path fill="none" stroke="#0000ff" d="M95.0179,-171.7616C95.0179,-160.3597 95.0179,-145.4342 95.0179,-132.494"></path>
<polygon fill="#0000ff" stroke="#0000ff" points="98.518,-132.2121 95.0179,-122.2121 91.518,-132.2121 98.518,-132.2121"></polygon>
<text text-anchor="middle" x="127.492" y="-142.8" font-family="Times,serif" font-size="14.00" fill="#000000"> COMPILE</text>
</g>
<!-- backend language -->
<g id="node6" class="node">
<title>backend language</title>
<ellipse fill="none" stroke="#000000" cx="95.0179" cy="-18" rx="95.0358" ry="18"></ellipse>
<text text-anchor="middle" x="95.0179" y="-13.8" font-family="Courier,monospace" font-size="14.00" fill="#000000">backend language</text>
</g>
<!-- abstract IR&#45;&gt;backend language -->
<g id="edge5" class="edge">
<title>abstract IR-&gt;backend language</title>
<path fill="none" stroke="#000000" d="M95.0179,-85.7616C95.0179,-74.3597 95.0179,-59.4342 95.0179,-46.494"></path>
<polygon fill="#000000" stroke="#000000" points="98.518,-46.2121 95.0179,-36.2121 91.518,-46.2121 98.518,-46.2121"></polygon>
<text text-anchor="middle" x="130.2093" y="-56.8" font-family="Times,serif" font-size="14.00" fill="#000000"> CODEGEN</text>
</g>
</g>
</svg>

<p>We will look at the transformation from <code>core</code> to <code>abstract IR</code>. In Haskell, this corresponds to the transformation from GHC Core to STG. This process is interesting because it is here that we define <em>how the program is evaluated</em>. We will look at several different designs for compilers, of increasing complexity, and consider problems such as laziness, sharing, garbage collection, strictness analysis and parallel evaluation.</p>
<p>This series is heavily based on a fantastic book of the same name written by Simon Peyton Jones and David Lester in 2000. All credit goes to them for the content: I’ve simply altered the presentation and updated it slightly. There are a number of differences:</p>
<ul>
<li>The book uses Miranda as its implementation language, whereas we will use Haskell.</li>
<li>Some time is spent in the book on introducing parser combinators and pretty printing, whereas we will not focus on these them. Parsing and pretty printing are topics in their own right, and there are better introductions to them elsewhere.</li>
<li>No external libraries are used in the book, whereas we will use a few common ones in the interest of brevity.</li>
<li>We will spend time on building a framework for visualising the evaluation process, as I think that makes it easier to understand how the compiler works.</li>
</ul>
<p>The book is freely available in PDF form <a href="https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/">here</a>. There’s also a broader overview of this area (again by Simon Peyton Jones) available <a href="https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/">here</a>. I highly recommend both of them.</p>
<h2 id="structure">Structure</h2>
<p>The structure of this series is as follows. However this is a work in progress, so I may change things as I complete each section.</p>
<ol type="1">
<li><a href="2019-03-03-the-core-language.html">The Core Language</a></li>
<li><a href="2019-03-09-graph-reduction.html">Graph Reduction</a></li>
<li>Template Instantiation</li>
<li>The G-machine</li>
<li>The Three Instruction Machine</li>
<li>The Parallel G-machine</li>
<li>Lambda Lifting</li>
<li>The Spineless Tagless G-machine</li>
<li><a href="2019-03-03-printing-core.html">Appendix: Printing Core</a></li>
<li><a href="2019-03-08-parsing-core.html">Appendix: Parsing Core</a></li>
</ol>
<p>Each post will be a literate Haskell file, and will compile using Stackage <code>lts-12.2</code>. We’ll use several libraries from Hackage, so you’ll want to make sure you’re using the same versions. Compiling with Stack and <code>lts-12.2</code> is the easiest way to do this.</p>
  </body>
</html>
